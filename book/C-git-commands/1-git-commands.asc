[appendix]
== Команды Git

В этой книге было показано больше десятка различных команд Git и мы приложили много усилий, чтобы рассказать вам о них, выстроив некий логический порядок, постепенно внедряя команды в сюжет. Но такой подход "размазал" описания команд по всей книге.

В этом приложении мы пройдёмся по всем командам, о которых шла речь, и сгруппируем их по смыслу. Мы расскажем, что делает каждая команда и укажем главы в книге, где эта команда использовалась.


=== Настройка и конфигурация

Две довольно распространённые команды, используемые как сразу после установки Git'а, так и в повседневной практике для настройки и получения помощи — это `config` и `help`.

==== git config

Сотни вещей в Git'е работают без всякой конфигурации, используя параметры по умолчанию. Для большинства из них вы можете задать иные умолчания, либо вовсе использовать собственные значения. Это включает в себя целый ряд настроек, начиная от вашего имени и заканчивая цветами в терминале и вашим любимым редактором. Команда `config` хранит и читает настройки в нескольких файлах, так что вы можете задавать значения глобально или для конкретных репозиториев.

Команда `git config` используется практически в каждой главе этой книги.

В главе <<_first_time>> мы использовали эту команду для указания имени, адреса электронной почты и редактора ещё до того, как начать использовать Git.

В главе  <<_git_aliases>> мы показали, как можно использовать её для создания сокращённых вариантов команд с длинными списками опций, чтобы не печатать их все каждый раз.

В главе <<_rebasing>> мы использовали `config` чтобы задать поведение `--rebase` по умолчанию для команды `git pull`.

В главе <<_credential_caching>> мы использовали её для задания хранилища ваших HTTP паролей.

В главе <<_keyword_expansion>> мы показали как настроить фильтры содержимого для данных, перемещаемых между индексом и рабочей директорией.

Ну и практически вся глава <<_git_config>> посвящена этой команде.

==== git help

Команда `git help` служит для отображения встроенной документации Git о других командах. И хотя мы приводим описания самых популярных команд в этой главе, полный список параметров и флагов каждой команды доступен через `git help <command>`.

Мы представили эту команду в главе <<_git_help>> и показали как её использовать, чтобы найти больше информации о команде `git shell` в главе <<_setting_up_server>>.


=== Клонирование и создание репозиториев

Существует два способа создать Git репозиторий. Первый — клонировать его из существующего репозитория (например, по сети); второй — создать репозиторий в существующей директории.

==== git init

Чтобы превратить обычную директорию в Git репозиторий и начать версионировать файлы в ней, просто запустите `git init`.

Впервые мы продемонстрировали эту команду в главе <<_getting_a_repo>> на примере создания нового репозитория для последующей работы с ним.

Мы немного поговорили о смене названия ветки по умолчанию с "master" на что-нибудь другое в главе <<_remote_branches>>.

Мы использовали эту команду для создания чистого репозитория для работы на стороне сервера в главе <<_bare_repo>>.

Ну и наконец мы немного покопались во внутренностях этой команды в главе <<_plumbing_porcelain>>.

==== git clone

На самом деле `git clone` работает как обёртка над некоторыми другими командами. Она создаёт новую директорию, переходит внутрь и выполняет `git init` для создания пустого репозитория, затем она добавляет новый удалённый репозиторий (`git remote add`) для указанного URL (по умолчанию он получит имя `origin`), выполняет `git fetch` для этого репозитория и, наконец, обновляет вашу рабочую директорию до последнего коміту, используя `git checkout`.

Команда `git clone` используется в десятке различных мест в этой книге, но мы перечислим наиболее интересные упоминания.

Первоначальное знакомство происходит в главе <<_git_cloning>>, где мы даём немного объяснений и приводим несколько примеров.

В главе <<_git_on_the_server>> мы рассмотрели как использовать опцию `--bare`, чтобы создать копию Git репозитория без рабочей директории.

В главе <<_bundling>> мы использовали `git clone` для распаковки упакованного с помощью `git bundle` репозитория.

Наконец, в главе <<_cloning_submodules>> мы научились использовать опцию `--recursive` чтобы упростить клонирование репозитория с субмодулями.

И хотя `git clone` используется во многих других местах в книге, перечисленные выше так или иначе отличаются от других вариантов использования.


=== Основные команды

Всего несколько команд нужно для базового варианта использования Git для ведения истории изменений.

==== git add

Команда `git add` добавляет содержимое рабочей директории в индекс (staging area) для последующего коміту. По умолчанию `git commit` использует лишь этот индекс, так что вы можете использовать `git add` для сборки слепка вашего следующего коміту.

Это одна из ключевых команд Git, мы упоминали о ней десятки раз на страницах книги. Ниже перечислены наиболее интересные варианты использования этой команды.

Знакомство с этой командой происходит в главе <<_tracking_files>>.

О том как использовать `git add` для разрешения конфликтов слияния написано в главе <<_basic_merge_conflicts>>.

В главе <<_interactive_staging>> показано как использовать `git add` для добавления в индекс лишь отдельных частей изменённого файла.

В главе <<_tree_objects>> показано как эта команда работает на низком уровне, чтобы вы понимали, что происходит за кулисами.

==== git status

Команда `git status` показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коміту в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

Мы познакомили вас с этой командой в главе <<_checking_status>>, разобрали стандартный и упрощённый формат вывода. И хотя мы использовали `git status` повсеместно в этой книге, практически все варианты использования покрыты в указанной главе.

==== git diff

Команда `git diff` используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей директорией и индексом (собственно `git diff`), разница между индексом и последним комітом (`git diff --staged`), или между любыми двумя комітами (`git diff master branchB`).

Мы познакомили вас с основами этой команды в главе <<_git_diff_staged>>, где показали как посмотреть какие изменения уже добавлены в индекс, а какие — ещё нет.

О том как использовать эту команду для проверки на проблемы с пробелами с помощью аргумента `--check` можно почитать в главе <<_commit_guidelines>>.

Мы показали вам как эффективно сравнивать ветки используя синтаксис `git diff A...B` в главе <<_what_is_introduced>>.

В главе <<_advanced_merging>> показано использование опции `-w` для скрытия различий в пробельных символах, а также рассказано как сравнивать конфликтующие изменения с опциями `--theirs`, `--ours` и `--base`.

Использование этой команды с опцией `--submodule` для сравнения изменений в субмодулях показано в главе <<_starting_submodules>>.

==== git difftool

Команда `git difftool` просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика `git diff`.

Мы лишь вкратце упомянули о ней в главе <<_git_diff_staged>>.

==== git commit

Команда `git commit` берёт все данные, добавленные в индекс с помощью `git add`, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

Вы познакомились с основами модели комітів в главе <<_committing_changes>>. Там же мы продемонстрировали использование опций `-a` для добавления всех изменений в индекс без использования `git add`, что может быть удобным в повседневном использовании, и `-m` для передачи сообщения коміту без запуска полноценного редактора.

В главе <<_undoing>> мы рассказали об опции `--amend`, используемой для изменения последнего совершённого коміту.

В главе <<_git_branches_overview>> мы более подробно познакомились с тем, что делает команда `git commit` и почему она делает это именно так.

Мы показали вам как подписывать ваши коміти, используя опцию `-S` в главе <<_signing_commits>>.

И наконец мы заглянули внутрь команды `git commit` в главе <<_git_commit_objects>> и узнали что она делает за кулисами.

==== git reset

Команда `git reset`, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель `HEAD` и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочей директории при использовании параметра `--hard`, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

Мы рассказали об основах использования `git reset` в главе <<_unstaging>>, где эта команда использовалась для удаления файла из индекса, добавленного туда с помощью `git add`.

В главе <<_git_reset>>, полностью посвящённой этой команде, мы разобрались в деталях её использования.

Мы использовали `git reset --hard` чтобы отменить слияние в главе <<_abort_merge>>, там же было продемонстрировано использование команды `git merge --abort` для этих целей, которая работает как обёртка над `git reset`.

==== git rm

Команда `git rm` используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на `git add` с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коміту.

Мы немного разобрались с этой командой в главе <<_removing_files>>, показали как удалять файлы из рабочей директории и индекса и только из индекса, используя флаг `--cached`.

Ещё один вариант использования `git rm` приведён в главе <<_removing_objects>>, где мы вкратце объяснили как использовать опцию `--ignore-unmatch` при выполнении `git filter-branch`, которая подавляет ошибки удаления несуществующих файлов. Это может быть полезно для автоматически выполняемых скриптов.

==== git mv

Команда `git mv` — это всего лишь удобный способ переместить файл, а затем выполнить `git add` для нового файла и `git rm` для старого.

Мы лишь вкратце упомянули это команду в главе <<_git_mv>>.

==== git clean

Команда `git clean` используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

Мы рассмотрели множество опций и сценариев использования этой команды в главе <<_git_clean>>.

=== Ветвление и слияния

За создание новых веток и слияние их воедино отвечает несколько Git команд.

==== git branch

Команда `git branch` — это своего рода "менеджер веток". Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.

Большая часть главы <<_git_branching>> посвящена этой команде, она используется повсеместно в этой главе. Впервые команда `branch` была представлена в разделе <<_create_new_branch>>, а большинство таких её фич как перечисление и удаление веток были разобраны в разделе <<_branch_management>>.

В главе <<_tracking_branches>> мы показали как использовать сочетание `git branch -u` для отслеживания веток.

Наконец, мы разобрались что происходит за кулисами этой команды в главе <<_git_refs>>.

==== git checkout

Команда `git checkout` используется для переключения веток и выгрузки их содержимого в рабочую директорию.

Мы познакомились с этой командой в главе <<_switching_branches>> вместе с `git branch`.

В главе <<_tracking_branches>> мы узнали как использовать флаг `--track` для отслеживания веток.

В главе <<_checking_out_conflicts>> мы использовали эту команду с опцией `--conflict=diff3` для разрешения конфликтов заново, в случае если предыдущее решение не подходило по некоторым причинам.

Мы рассмотрел детали взаимосвязи этой команды и `git reset` в главе <<_git_reset>>.

Мы исследовали внутренние механизмы этой команды в главе <<_the_head>>.

==== git merge

Команда `git merge` используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коміт.

Мы познакомили вас с этой командой в главе <<_basic_branching>>. И хотя `git merge` встречается в этой книге повсеместно, практически все использования имеют вид `git merge <branch>` с указанием единственной ветки для слияния.

Мы узнали как делать "сплющенные" слияния (когда Git делает слияние в виде нового коміту, без сохранения всей истории работы) в конце главы <<_public_project>>.

В главе <<_advanced_merging>> мы глубже разобрались с процессом слияния и этой командой, включая флаги `-Xignore-all-whitespace` и `--abort`, используемый для отмены слияния в случае возникновения проблем.

Мы научились проверять криптографические подписи перед слияниями если ваш проект использует GPG в главе <<_signing_commits>>.

Ну и наконец в главе <<_subtree_merge>> мы познакомились со слиянием поддеревьев.

==== git mergetool

Команда `git mergetool` просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

Мы вкратце упомянули о ней в главе <<_basic_merge_conflicts>> и рассказали как настроить свою программу слияния в главе <<_external_merge_tools>>.

==== git log

Команда `git log` используется для просмотра истории комітів, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне комітів.

Практически во всех главах книги эта команда используется для демонстрации истории проекта.

Мы познакомились c `git log` и некоторыми её деталями в главе <<_viewing_history>>. Там мы видели использование опций `-p` и `--stat` для получения представления об изменениях в каждом коміті, а также `--pretty` and `--oneline` для настройки формата вывода этой команды — более полным и подробным или кратким.

В главе <<_create_new_branch>> мы использовали опцию `--decorate` чтобы отобразить указатели веток на истории комітів, а также `--graph` чтобы просматривать историю в виде дерева.

В главах <<_private_team>> и <<_commit_ranges>> мы рассмотрели синтаксис `branchA..branchB` для просмотра уникальных для заданной ветки комітів. Мы часто использовали этот приём в <<_commit_ranges>>.

В главах <<_merge_log>> и <<_triple_dot>> мы рассмотрели синтаксис `branchA...branchB` и опцию `--left-right` для просмотра что находится в первой, либо второй ветке, но не сразу в обеих. Также в главе <<_merge_log>> рассмотрели опцию `--merge`, которая может быть полезной при разрешении конфликтов, а также `--cc` для просмотра конфликтов слияния в истории проекта.

В главе <<_git_reflog>> мы использовали опцию `-g` для вывода `git reflog`, используя `git log`.

В главе <<_searching>> мы рассмотрели использование опций `-S` и `-L` для поиска событий в истории проекта, например, истории развития какой-либо фичи.

В главе <<_signing_commits>> мы показали, как использовать опцию `--show-signature` для отображения строки валидации подписи для каждого коміту в `git log`.

==== git stash

Команда `git stash` используется для временного сохранения всех незакомічених изменений для очистки рабочей директории без необходимости комітити незавершённую работу в новую ветку.

Эта команда практически целиком раскрыта в главе <<_git_stashing>>.

==== git tag

Команда `git tag` используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

Мы познакомились и разобрались с ней в главе <<_git_tagging>> и использовали на практике в <<_tagging_releases>>.

Мы научились создавать подписанные с помощью GPG метки, используя флаг `-s`, и проверять их, используя флаг `-v`, в главе <<_signing>>.


=== Совместная работа и обновление проектов

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

==== git fetch

Команда `git fetch` связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

Мы познакомились с ней в главе <<_fetching_and_pulling>> и продолжили знакомство в <<_remote_branches>>.

Мы использовали эту команду в нескольких примерах из главы <<_contributing_project>>.

Мы использовали её для скачивания запросов на слияние (pull request) из других репозиториев в главе <<_pr_refs>>, также мы рассмотрели использование `git fetch` для работы с упакованными репозиториями в главе <<_bundling>>.

Мы рассмотрели тонкую настройку `git fetch` в главe и <<_refspec>>.

==== git pull

Команда `git pull` работает как комбинация команд `git fetch` и `git merge`, т.е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

Мы познакомились с ней в главе <<_fetching_and_pulling>> и показали как узнать, какие изменения будут приняты в случае применения в главе <<_inspecting_remote>>.

Мы также увидели как она может оказаться полезной для разрешения сложностей при перемещении веток в главе <<_rebase_rebase>>.

Мы показали как можно использовать только URL удалённого репозитория без сохранения его в списке удалённых репозиториев в главе <<_checking_out_remotes>>.

И наконец мы показали как проверять криптографические подписи полученных комітів, используя опцию `--verify-signatures` в главе <<_signing_commits>>.

==== git push

Команда `git push` используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

Мы познакомились с этой командой в главе <<_pushing_remotes>>. Там мы рассмотрели основы обновления веток в удалённом репозитории. В главе <<_pushing_branches>> мы подробнее познакомились с этой командой, а в <<_tracking_branches>> мы узнали как настроить отслеживание веток для автоматической передачи на удалённый репозиторий. В главе <<_delete_branches>> мы использовали флаг `--delete` для удаления веток на сервере, используя `git push`.

На протяжении главы <<_contributing_project>> мы показали несколько примеров использования `git push` для совместной работы в нескольких удалённых репозиториях одновременно.

В главе <<_publishing_submodules>> мы использовали опцию `--recurse-submodules` чтобы удостовериться, что все субмодули будут опубликованы перед отправкой на проекта на сервер, что может быть реально полезным при работе с репозиториями, содержащими субмодули.

В главе <<_other_client_hooks>> мы поговорили о триггере `pre-push`, который может быть выполнен перед отправкой данных, чтобы проверить возможность этой отправки.

Наконец, в главе <<_pushing_refspecs>> мы рассмотрели передачу данных с полным указанием передаваемых ссылок, вместо использования распространённых сокращений. Это может быть полезным если вы хотите очень точно указать, какими изменениями хотите поделиться.

==== git remote

Команда `git remote` служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например "origin", так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и `git remote` поможет добавлять, изменять и удалять их.

Эта команда детально рассмотрена в главе <<_remote_repos>>, включая вывод списка удалённых репозиториев, добавление новых, удаление или переименование существующих.

Она используется практически в каждой главе, но всегда в одном и том же виде: `git remote add <имя> <URL>`.

==== git archive

Команда `git archive` используется для упаковки в архив указанных комітів или всего репозитория.

Мы использовали `git archive` для для создания тарбола (`tar.gz` файла) всего проекта для передачи по сети в главе <<_preparing_release>>.

==== git submodule

Команда  `git submodule` используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды `submodule` есть несколько под-команд — `add`, `update`, `sync` и др. — для управления такими репозиториями.

Эта команда упомянута и полностью раскрыта в главе <<_git_submodules>>.

=== Осмотр и сравнение

==== git show

Команда `git show` отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коміті.

Впервые мы использовали её для просмотра информации об аннотированой метке в главе <<_annotated_tags>>.

В главе <<_revision_selection>> мы использовали её для показа комітів, подпадающих под различные селекторы диапазонов.

Ещё одна интересная вещь, которую мы проделывали с помощью `git show` в главе <<_manual_remerge>> — это извлечение содержимого файлов на различных стадиях во время конфликта слияния.

==== git shortlog

Команда `git shortlog` служит для подведения итогов команды `git log`. Она принимает практически те же параметры, что и `git log`, но вместо простого листинга всех комітів, они будут сгруппированы по автору.

Мы показали, как можно использовать эту команду для создания классных списков изменений (changelogs) в главе <<_the_shortlog>>.

==== git describe

Команда `git describe` принимает на вход что угодно, что можно трактовать как коміт (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коміту. Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

Мы использовали `git describe` в главах <<_build_number>> и <<_preparing_release>> чтобы сгенерировать название для архивного файла с релизом.


=== Отладка

В Git есть несколько команд, используемых для нахождения проблем в коде. Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

==== git bisect

Команда `git bisect` — это чрезвычайно полезная утилита для поиска коміту в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

О ней упоминается только в главе <<_binary_search>>, где она полностью и раскрыта.

==== git blame

Команда `git blame` выводит перед каждой строкой файла SHA-1 коміту, последний раз менявшего эту строку и автора этого коміту. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

Эта команда полностью разобрана в главе <<_file_annotation>>.

==== git grep

Команда `git grep` используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.

Она полностью разобрана в разделе <<_git_grep>> и упоминается лишь там.

=== Внесение исправлений

Некоторые команды в Git основываются на подходе к рассмотрению комітів в терминах внесённых ими изменений, т.е. рассматривают историю комітів как цепочку патчей. Ниже перечислены эти команды.

==== git cherry-pick

Команда `git cherry-pick` используется для того чтобы взять изменения, внесённые каким-либо комітом, и попытаться применить их заново в виде нового коміту наверху текущей ветки. Это может оказаться полезным чтобы забрать парочку комітів из другой ветки без полного слияния с той веткой.

Мы продемонстрировали работу этой команды в главе <<_rebase_cherry_pick>>.

==== git rebase

`git rebase` — это "автоматизированный" `cherry-pick`. Он выполняет ту же работу, но для цепочки комітів, тем самым как бы перенося ветку на новое место.

Мы в деталях разобрались с механизмом переноса веток в главе <<_rebasing>>, включая рассмотрение потенциальных проблем переноса опубликованных веток при совместной работе.

Мы использовали эту команду на практике для разбиения истории на два репозитория в главе <<_replace>>, наряду с использованием флага `--onto`.

В главе <<_rerere>> мы рассмотрели случай возникновения конфликта во время переноса комітів.

Также мы познакомились с интерактивным вариантом `git rebase`, включающемся с помощью опции `-i`, в главе <<_changing_multiple>>.

==== git revert

Команда `git revert` — полная противоположность `git cherry-pick`. Она создаёт "антикоміт" для указанного коміту, таким образом отменяя изменения, внесённые в нём..

Мы использовали её в главе <<_reverse_commit>> чтобы отменить коміт слияния (merge commit).

=== Работа с помощью электронной почты

Множество проектов, использующих Git (включая сам Git), активно используют списки рассылок для координирования процесса разработки. В Git есть несколько команд, помогающих в этом, начиная от генерации патчей, готовых к пересылке по электронной почте, заканчивая применением таких патчей прямиком из папки "входящие".

==== git apply

Команда `git apply` применяет патч, сформированный с помощью команды `git diff` или `GNU diff`. Она делает практически то же самое, что и команда `patch`.

Мы продемонстрировали использование этой команды в главе <<_patches_from_email>> и описали случаи, когда вы возможно захотите ею воспользоваться.

==== git am

Команда `git am` используется для применения патчей из ящика входящих сообщений электронной почты, в частности, тех что используют формат `mbox`. Это используется для простого получения изменений через email и применения их к проекту.

Мы рассмотрели использование этой команды в главе <<_git_am>>, включая такие опции как `--resolved`, `-i` и `-3`.

Существует набор триггеров, которые могут оказаться полезными при использовании `git am` для процесса разработки. О них рассказано в главе <<_email_hooks>>.

Также мы использовали `git am` для применения сформированного из Github'овского запроса на слияние patch-файла в главе <<_email_notifications>>.

==== git format-patch

Команда `git format-patch` используется для создания набора патчей в формате `mbox` которые можно использовать для отправки в список рассылки.

Мы рассмотрели процесс отсылки изменений в проект, использующий email для разработки в главе <<_project_over_email>>.

==== git send-email

Команда `git send-email` используется для отсылки патчей, сформированных с использованием `git format-patch`, по электронной почте.

Процесс отсылки изменений по электронной почте в проект рассмотрен в главе <<_project_over_email>>.

==== git request-pull

Команда `git request-pull` используется для генерации примерного текста сообщения для отсылки кому-либо. Если у вас есть ветка, хранящаяся на публичном сервере, и вы хотите чтобы кто-либо забрал эти изменения без возни с отсылкой патчей по электронной почте, вы можете выполнить эту команду и послать её вывод тому человеку.

Мы показали, как пользоваться этой командой в главе <<_public_project>>.

=== Внешние системы

В Git есть несколько стандартных команд для работы с другими системами контроля версий.

==== git svn

Команда `git svn` используется для работы с сервером Subversion. Это означает, что вы можете использовать Git в качестве SVN клиента, забирать изменения и отправлять свои собственные на сервер Subversion.

Мы разобрались с этой командой в главе <<_git_svn>>.

==== git fast-import

Для других систем контроля версий, либо для импорта произвольно форматированных данных, вы можете использовать `git fast-import`, которая умеет преобразовывать данные в формат, понятный Git'у.

Мы детально рассмотрели эту команду в главе  <<_custom_importer>>.

=== Администрирование

Если вы администрируете Git репозиторий или вам нужно исправить что-либо, Git предоставляет несколько административных команд вам в помощь.

==== git gc

Команда `git gc` запускает сборщик мусора в вашем репозитории, который удаляет ненужные файлы из хранилища объектов и эффективно упаковывает оставшиеся файлы.

Обычно, эта команда выполняется автоматически без вашего участия, но, если пожелаете, можете вызвать её вручную. Мы рассмотрели некоторые примеры её использования в главе <<_git_gc>>.

==== git fsck

Команда `git fsck` используется для проверки внутренней базы данных на предмет наличия ошибок и несоответствий.

Мы лишь однажды использовали её в главе <<_data_recovery>> для поиска более недостижимых (dangling) объектов.

==== git reflog

Команда `git reflog` просматривает историю изменения голов веток на протяжении вашей работы для поиска комітів, которые вы могли внезапно потерять, переписывая историю.

В основном, мы рассматривали эту команду в главе <<_git_reflog>>, где мы показали пример использования этой команды, а также как использовать `git log -g` для просмотра той же информации, используя `git log`.

Мы на практике рассмотрели восстановление потерянной ветки в главе <<_data_recovery>>.

==== git filter-branch

Команда `git filter-branch` используется для переписывания содержимого комітів по заданному алгоритму, например, для полного удаления файла из истории или для вычленения истории лишь части файлов в проекте для вынесения в отдельный репозиторий.

В главе <<_removing_file_every_commit>> мы объяснили механизм работы этой команды и рассказали про использование опций `--commit-filter`, `--subdirectory-filter` и `--tree-filter`.

В главах <<_git_p4>> и <<_git_tfs>> мы использовали эту команду для исправления импортированных репозиториев.


=== Низкоуровневые команды

Также в этой книге встречались некоторые низкоуровневые ("сантехнические") команды.

Первая из них — это `ls-remote`, с которой мы столкнулись в главе <<_pr_refs>> и использовали для просмотра ссылок на сервере.

В главах <<_manual_remerge>>, <<_rerere>> и <<_the_index>> мы использовали команду `ls-files` чтобы просмотреть "сырые" данные в индексе.

Мы также упоминали о команде `rev-parse` в главе <<_branch_references>>, используемой для превращения практически произвольно отформатированных строк в SHA-1 указатели.

Так или иначе, большинство низкоуровневых команд собрано в главе <<_git_internals>>, которая на них и сосредоточена. Мы старались избегать этих команд в других местах в этой книге.
