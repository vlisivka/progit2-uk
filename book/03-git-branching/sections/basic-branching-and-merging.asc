=== Основи розгалуження і злиття

Давайте розглянемо простий приклад робочого процесу, який може бути корисним у вашому проекті.
Ваша робота побудована так:

. Ви працюєте над сайтом.
. Ви створюєте гілку для нової статті, яку ви пишете.
. Ви працюєте в цій гілці.

У цей момент ви отримуєте повідомлення, що виявлена критична помилка, що вимагає якнайшвидшого виправлення.
Ваші дії:

. Перемкнутися на основну гілку.
. Створити гілку для додавання виправлення.
. Після тестування, злити гілку, яка містить виправлення, з основною гілкою.
. Перемкнутися назад в ту гілку де ви пишете статтю і продовжити працювати.

[[_basic_branching]]
==== Основи розгалуження

(((branches, basic workflow)))
Припустимо, ви працюєте над проектом і вже маєте декілька комітів.

.Проста історія комітів
image::images/basic-branching-1.png[Простая история комітів.]

Ви вирішуєте, що тепер ви будете займатися проблемою #53  з вашої системи відстеження помилок.
Щоб створити гілку і відразу перемкнутися на неї, можна виконати команду `git checkout` з параметром `-b`:

[source,console]
----
$ git checkout -b iss53
Switched to a new branch "iss53"
----

Це теж саме що і:

[source,console]
----
$ git branch iss53
$ git checkout iss53
----

.Створення нового покажчика гілки
image::images/basic-branching-2.png[Створення нового покажчика гілки.]

Ви працюєте над своїм сайтом і робите коміт.
Це призводить до того, що гілка `iss53` рухається вперед, так як ви перемкнулися на неї раніше (` HEAD` вказує на неї).

[source,console]
----
$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'
----

.Гілка iss53 рухається вперед
image::images/basic-branching-3.png[Гілка iss53 рухається вперед.]

Тут ви отримуєте повідомлення про виявлення вразливості на вашому сайті, яку потрібно негайно усунути.
Завдяки Git, не потрібно розміщувати це виправлення разом з тим, що ви зробили в `iss53`. Вам навіть не доведеться докладати зусиль, щоб відкотити всі ці зміни для початку роботи над виправленням.
Все, що вам потрібно - це перемкнутися на гілку `master`.

Але перед тим як зробити це - майте на увазі, що якщо ваш робочий каталог або область підготовлених файлів містять зміни, що не потрапили в коміт і які конфліктують з гілкою, на яку ви хочете перейти, то Git не дозволить вам перемкнути гілки.
Найкраще перемикатися з чистого робочого стану проекту.
Є способи обійти це (заховати (stash) або виправити (amend) коміти), але про це ми поговоримо пізніше в главі <<_git_stashing>>.
Тепер припустимо, що ви зафіксували всі свої зміни і можете перемкнутися на основну гілку:

[source,console]
----
$ git checkout master
Switched to branch 'master'
----

З цього моменту ваш робочий каталог має точно такий же вид, який був перед початком роботи над проблемою #53. Тепер ви можете зосередитися на роботі над виправленням.
Важливо запам'ятати: коли ви перемикаєте гілки, Git повертає стан робочого каталогу до того вигляду, який він мав у момент останнього коміту в цю гілку.
Він додає, видаляє і змінює файли автоматично, щоб стан робочого каталогу відповідав тому, коли був зроблений останній коміт.

Тепер ви можете перейти до написання виправлення.
Давайте створимо нову гілку для виправлення, в якій будемо працювати, поки не закінчимо виправлення.

[source,console]
----
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)
----

.Гілка hotfix заснована на гілці `master`
image::images/basic-branching-4.png[Гілка hotfix заснована на гілці `master`.]

Ви можете прогнати тести, щоб переконатися, що ваше виправлення робить саме те, що потрібно. І якщо це так - виконати злиття (merge) з основною гілкою для включення в продукт.
Це робиться командою `git merge`:(((git commands, merge)))

[source,console]
----
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
----

Помітили фразу ``fast-forward'' в цьому злитті?
Через те, що коміт, на який вказувала гілка, яку ви злили, був прямим нащадком того коміту, на якому ви перебували, Git просто перемістив покажчик гілки вперед.
Іншими словами, якщо коміт зливається з тим, до якого можна дістатися, рухаючись по історії прямо, Git спрощує злиття, просто переносячи покажчик мітки вперед (так як немає розгалуження в роботі). Це називається `` fast-forward`` (перемотування).
Тепер ваші зміни - в знімку (snapshot) коміту, на який вказує гілка `master`, і виправлення продукту можна впроваджувати.

.`master` перемотано до `hotfix`
image::images/basic-branching-5.png[`master` перемотано до `hotfix`.]

Після впровадження вашого архіважливого виправлення, ви готові повернутися до роботи над тим, що були змушені відкласти.
Як би там не було, спочатку потрібно видалити гілку `hotfix`, тому що вона більше не потрібна - гілка `master` вказує на те ж саме місце.
Для видалення гілки виконайте команду `git branch` з параметром `-d`:

[source,console]
----
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
----

Тепер ви можете перемкнути гілку і повернутися до роботи над своєю проблемою #53:

[source,console]
----
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
----

.Продовження роботи над `iss53`
image::images/basic-branching-6.png[Продовження роботи над `iss53`.]

Варто звернути увагу на те, що всі зміни з гілки `hotfix` не включені в вашу гілку `iss53`.
Якщо їх потрібно включити, ви можете влити гілку `master` у вашу гілку` iss53` командою `git merge master`, або ж ви можете відкласти злиття цих змін до завершення роботи, і потім влити гілку` iss53` в `master`.

[[_basic_merging]]
==== Основи злиття

(((branches, merging)))(((merging)))
Припустимо, ви вирішили, що робота над проблемою #53 закінчена, і її можна влити в гілку `master`.
Для цього потрібно виконати злиття гілки `iss53` точно так само, як ви робили це з гілкою `hotfix` раніше.
Все що потрібно зробити - перемкнутися на гілку, в яку ви хочете включити зміни, і виконати команду `git merge`:

[source,console]
----
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
----

Результат цієї операції відрізняється від результату злиття гілки `hotfix`.
В даному випадку, у нас історія роботи розгалузилася.
Так як коміт, на якому ми знаходимося, не є прямим нащадком гілки, з якою ми виконуємо злиття, то Git доведеться трохи попрацювати.
У цьому випадку Git виконує просте тристороннє злиття двох знімків (snapshot) гілок, які зливаються, і спільного для двох гілок батьківського знімка.

.Використання трьох знімків при злитті
image::images/basic-merging-1.png[Використання трьох знімків при злитті.]

Замість того, щоб просто пересунути покажчик гілки вперед, Git створює новий знімок-результат тристороннього злиття, а потім автоматично робить коміт.
Цей особливий коміт називають комітом злиття, так як у нього більше одного предка.

.Коміт злиття
image::images/basic-merging-2.png[Коміт злиття.]

Варто відзначити, що Git сам визначає найкращого загального предка, як основу для злиття; це відрізняє його від старішиї інструментів, таких як CVS або Subversion (до версії 1.5), де розробникам доводиться самим знаходити найкращу основу.
Це шалено спрощує злиття в Git в порівнянні з вказаними системами.

Тепер, коли робота влита, гілка `iss53` більше не потрібна.
Ви можете закрити запит в системі відстеження помилок і видалити гілку:

[source,console]
----
$ git branch -d iss53
----

[[_basic_merge_conflicts]]
==== Основні конфлікти злиття

(((merging, conflicts)))
Іноді процес не проходить гладенько.
Якщо ви змінили одну і ту ж частину одного і того ж файлу по-різному в двох поєднуваних гілках, Git не зможе їх об'єднати чисто .
Якщо ваше виправлення помилки #53 зажадало змінити ту ж частину файлу, що і `hotfix`, ви отримаєте приблизно таке повідомлення про конфлікт злиття:

[source,console]
----
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
----

Git не створив коміт злиття автоматично.
Він зупинив процес до тих пір, поки ви не розв’язжете конфлікт.
Щоб у будь-який момент після появи конфлікту побачити, які файли не об'єднані, ви можете запустити `git status`:

[source,console]
----
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
----

Все, де є невирішені конфлікти злиття, перераховується як не об’єднане.
Git додає в конфлікті файли стандартні позначки для розв’язку конфліктів, щоб ви могли вручну відкрити їх і розв’язати конфлікти.
У вашому файлі з'явився розділ, що виглядає приблизно так:

[source,html]
----
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
----

Це означає, що версія з `HEAD` (вашої гілки` master`, оскільки саме її ви вивантажили, запустивши команду злиття) - це верхня частина блоку (все, що над `=======`), а версія з вашої гілки `iss53` представлена ​​в нижній частині.
Щоб розв'язати конфлікт, доведеться вибрати одну із сторін, або об'єднати вміст по-своєму.
Наприклад, ви можете розв’язати конфлікт, замінивши весь блок цим:

[source,html]
----
<div id="footer">
please contact us at email.support@github.com
</div>
----

У цьому розв’язку є трохи від кожної частини, а рядки `<<<<<<<`, `=======` і `>>>>>>>` зовсім прибрані.
Розв’язавши кожен конфлікт у всіх файлах, запустіть `git add` для кожного файлу, щоб відзначити конфлікт як розв’язаний.
Підготовка (staging) файлу позначає його для Git як розв’язаний конфлікт.

Якщо ви хочете використовувати графічний інструмент, можна запустити `git mergetool`, візуальний засіб для розв’язування конфліктів:(((git commands, mergetool)))

[source,console]
----
$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
----

Якщо ви хочете використовувати засіб злиття не за замовчуванням (в даному випадку Git вибрав `opendiff`, оскільки команда запускалася на Mac), список всіх підтримуваних інструментів представлений вгорі після фрази` `one of the following tools. ''
Просто введіть назву інструменту, який потрібно використовувати.

[NOTE]
====
Опис розширених засобів розв’язку складних конфліктів злиття ми наводимо в розділі <<_advanced_merging>>.
====

Після виходу із засобу злиття Git запитує, чи було успішним злиття.
Якщо ви ствердно відповісте скрипту, він підготує (stage) файл, щоб відзначити його як розв’язаний.
Тепер можна знову запустити `git status`, щоб переконатися, що всі конфлікти розв’язані:

[source,console]
----
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
----

Якщо це вас влаштовує, і ви переконалися, що всі файли, де були конфлікти, підготовлено (staged), можете ввести `git commit`, щоб завершити коміт злиття.
Коментар до коміту за замовчуванням виглядає приблизно так:

[source,console]
----
Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#    .git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#    modified:   index.html
#
----

Ви можете доповнити це повідомлення подробицями того, як були вирішені конфлікти, якщо вважаєте, що це допоможе іншим у майбутньому розібратися в злитті, якщо це не очевидно: що ви зробили і чому.

